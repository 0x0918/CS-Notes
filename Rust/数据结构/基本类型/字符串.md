# Rust 字符串

Rust 有两种主要的字符串类型：String 和 ＆str。有什么区别？

- &str 是一个简单的字符串。当你写 `let my_variable = "Hello, world!"`, 你创建了 &str，它的速度非常快。
- String 字符串是更复杂的字符串。它有点慢，并且功能更多。字符串是一个指针，在堆上有数据。

&str 和 String 都是 UTF-8，譬如：

```rs
fn main() {
    let name = "서태지"; // This is a Korean name. No problem, because a &str is UTF-8.
    let other_name = String::from("Adrian Fahrenheit Țepeș"); // Ț and ș are no problem in UTF-8.
}
```

您甚至可以借助 UTF-8 编写表情符号。

```rs
fn main() {
    let name = "😂";
    println!("My name is actually {}", name);
}
```

那么为什么我们在 str 前面需要一个＆而不是 String 呢？

- str 是动态类型，例如，名字 "서태지" 以及 "Adrian Fahrenheit Țepeș" 堆栈上的大小不同:

```rs
fn main() {
    println!("A String is always {:?} bytes. It is Sized.", std::mem::size_of::<String>()); // std::mem::size_of::<Type>() gives you the size in bytes of a type
    println!("And an i8 is always {:?} bytes. It is Sized.", std::mem::size_of::<i8>());
    println!("And an f64 is always {:?} bytes. It is Sized.", std::mem::size_of::<f64>());
    println!("But a &str? It can be anything. '서태지' is {:?} bytes. It is not Sized.", std::mem::size_of_val("서태지")); // std::mem::size_of_val() gives you the size in bytes of a variable
    println!("And 'Adrian Fahrenheit Țepeș' is {:?} bytes. It is not Sized.", std::mem::size_of_val("Adrian Fahrenheit Țepeș"));
}
```

这就是为什么我们需要一个 ＆ 的原因，因为 ＆ 会创建一个指针，而 Rust 知道指针的大小。因此，指针进入堆栈。如果我们写了 str，Rust 将不知道要做什么，因为它不知道大小。有很多方法可以制作字符串。这里有一些：

- `String::from("This is the string text");` 这是用于 String 的方法，该方法采用文本并创建 String。
- `"This is the string text".to_string()`，这是 ＆str 的方法，使它成为 String。
- format! 宏。这就像 println！除了它创建一个 String 而不是打印。因此，您可以执行以下操作：

```rs
fn main() {
    let my_name = "Billybrobby";
    let my_country = "USA";
    let my_home = "Korea";

    let together = format!(
        "I am {} and I come from {} but I live in {}.",
        my_name, my_country, my_home
    );
}
```

现在我们有了一个在一起命名的字符串，但尚未打印出来。此外，我们还可以使用 `.into()` 来创建字符串，某些类型可以使用 From 和 .into()轻松地与其他类型进行转换；如果您有 From，那么您也有.into()。 From 更清晰，因为您已经知道类型：您知道 `String::from("Some str"）` 是来自 ＆str 的 String。但是使用 .into()，有时编译器不知道：

```rs
fn main() {
    let my_string = "Try to make this a String".into(); // ⚠️
}

// Rust doesn't know what type you want, because many types can be made from a &str.

error[E0282]: type annotations needed
 --> src\main.rs:2:9
  |
2 |     let my_string = "Try to make this a String".into();
  |         ^^^^^^^^^ consider giving `my_string` a type

fn main() {
    let my_string: String = "Try to make this a String".into();
}
```
