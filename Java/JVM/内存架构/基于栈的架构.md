# JVM 架构与机制概述

其实说 Server 和 Client 是 JVM 的两种工作模式是不准确的，因为它们就是不同的虚拟机，因此应该说有两种类型的 JVM。第三行的输出中可以看到：JVM 的名字(HotSpot)、类型(Client)和 build ID(24.79-b02) 。除此之外，我们还知道 JVM 以混合模式(mixed mode)在运行，这是 HotSpot 默认的运行模式，意味着 JVM 在运行时可以动态的把字节码编译为本地代码。我们也可以看到类数据共享(class data sharing)是开启(即第三行最后的 sharing)的。类数据共享(class data sharing)是一种在只读缓存(在 jsa 文件中，”Java Shared Archive”)中存储 JRE 的系统类，被所有 Java 进程的类加载器用来当做共享资源，它可能在经常从 jar 文档中读所有的类数据的情况下显示出性能优势。
![](http://static.oschina.net/uploads/space/2015/0917/192918_c6O7_1434710.png)
那么，Client JVM 和 Server JVM 到底在哪些方面不同呢？当虚拟机运行在-client 模式的时候,使用的是一个代号为 C1 的轻量级编译器, 而-server 模式启动的虚拟机采用相对重量级,代号为 C2 的编译器. C2 比 C1 编译器编译的相对彻底,,服务起来之后,性能更高。-Server VM 启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。Oracle 官方网站的高频问题上这么解释的：
These two systems are different binaries. They are essentially two different compilers (JITs)interfacing to the same runtime system. The client system is optimal for applications which need fast startup times or small footprints, the server system is optimal for applications where the overall performance is most important. In general the client system is better suited for interactive applications such as GUIs. Some of the other differences include the compilation policy,heap defaults, and inlining policy.
大意是说，这两个 JVM 是使用的不同编译器。Client JVM 适合需要快速启动和较小内存空间的应用，它适合交互性的应用，比如 GUI；而 Server JVM 则是看重执行效率的应用的最佳选择。不同之处包括：编译策略、默认堆大小、内嵌策略。根据《The Java HotSpot Performance Engine Architecture》：
The Client VM compiler does not try to execute many of the more complex optimizations performed by the compiler in the Server VM, but in exchange, it requires less time to analyze and compile a piece of code. This means the Client VM can start up faster and requires a smaller memory footprint.
Note: It seems that the main cause of the difference in performance is the amount of optimizations.
The Server VM contains an advanced adaptive compiler that supports many of the same types of optimizations performed by optimizing C++ compilers, as well as some optimizations that cannot be done by traditional compilers, such as aggressive inlining across virtual method invocations. This is a competitive and performance advantage over static compilers. Adaptive optimization technology is very flexible in its approach, and typically outperforms even advanced static analysis and compilation techniques.
Both solutions deliver extremely reliable, secure, and maintainable environments to meet the demands of today’s enterprise customers.
很明显，Client VM 的编译器没有像 Server VM 一样执行许多复杂的优化算法，因此，它在分析和编译代码片段的时候更快。而 Server VM 则包含了一个高级的编译器，该编译器支持许多和在 C++编译器上执行的一样的优化，同时还包括许多传统的编译器无法实现的优化。

从 J2SE 5.0 开始，当一个应用启动的时候，加载器会尝试去检测应用是否运行在 “server-class” 的机器上，如果是，则使用 Java HotSpot Server Virtual Machine (server VM)而不是 Java HotSpot Client Virtual Machine (client VM)。这样做的目的是提高执行效率，即使没有为应用显式配置 VM。下面这张图展示了各个平台的默认的 JVM(注意：—代表不提供该平台的 JVM )：
![](http://static.oschina.net/uploads/space/2015/0918/213602_GsBV_1434710.png)

## 性能差异对比

### 初始堆大小差异

对于 Server JVM：
`$ java -XX:+PrintFlagsFinal -version 2>&1 | grep -i -E 'heapsize|permsize|version' uintx AdaptivePermSizeWeight = 20 {product} uintx ErgoHeapSizeLimit = 0 {product} uintx InitialHeapSize := 66328448 {product} uintx LargePageHeapSizeThreshold = 134217728 {product} uintx MaxHeapSize := 1063256064 {product} uintx MaxPermSize = 67108864 {pd product} uintx PermSize = 16777216 {pd product} java version "1.6.0_24"`
对于 Client JVM：
`$ java -client -XX:+PrintFlagsFinal -version 2>&1 | grep -i -E 'heapsize|permsize|version' uintx AdaptivePermSizeWeight = 20 {product} uintx ErgoHeapSizeLimit = 0 {product} uintx InitialHeapSize := 16777216 {product} uintx LargePageHeapSizeThreshold = 134217728 {product} uintx MaxHeapSize := 268435456 {product} uintx MaxPermSize = 67108864 {pd product} uintx PermSize = 12582912 {pd product} java version "1.6.0_24"`

### 效率对比

我们参考来自[Onkar Joshi’s blog](http://www.onkarjoshi.com/blog/174/hotspot-jvm-client-server-vm-optimization/)的例子：
`
public class LoopTest {
public static void main(String[] args) {
long start = System.currentTimeMillis();
spendTime();
long end = System.currentTimeMillis();
System.out.println(end-start);
}

    private static void spendTime() {
        for (int i =500000000;i>0;i--) {
        }
    }

}
`
这段代码只编译一次，只是运行这段代码的 JVM 不同而已。不要使用 Eclipse 中的 Run As,因为它会将代码重新编译。这里，我们使用 java 命令来执行这段代码：
![](http://www.onkarjoshi.com/blog/wp-content/uploads/2010/08/hotspot-server-client-vm.png)

## JVM 工作模式

在命令行里输入 java -X，你会看到以下结果：

![img](http://static.oschina.net/uploads/space/2015/0918/101804_8qYV_1434710.png)

其实这两个是 JVM 工作的模式。JVM 有以下几种模式：-Xint, -Xcomp, 和 -Xmixed。从上图的输出结果中也可以看到，mixed 是 JVM 的默认模式，其实在文章一开始的时候就提到了，因为在 java -version 命令中，输出了以下内容：
`Java HotSpot(TM) Client VM (build 24.79-b02, mixed mode, sharing)`
中间的 mixed mode 就说明当前 JVM 是工作在 mixed 模式下的。-Xint 和-Xcomp 参数和我们的日常工作不是很相关，但是我非常有兴趣通过它来了解下 JVM。

**-Xint 代表解释模式(interpreted mode)**，-Xint 标记会**强制 JVM 以解释方式执行所有的字节码**，当然这会降低运行速度，通常低 10 倍或更多。现在通过刚才的例子(没有重新编译过)来验证一下：

![img](http://static.oschina.net/uploads/space/2015/0918/102849_nVyP_1434710.png)

可以看到，在都使用 Client JVM 的前提下，混合模式下，平均耗时 150ms，然而在解释模式下，平均耗时超过 1600ms，这基本上是 10 倍以上的差距。

**-Xcomp 代表编译模式(compiled mode)**，与它(-Xint)正好相反，JVM 在第一次使用时会把**所有的字节码编译成本地代码**，从而带来最大程度的优化。这听起来不错，因为这完全绕开了缓慢的解释器。然而，很多应用在使用-Xcomp 也会有一些性能损失，但是这比使用-Xint 损失的少，原因是-Xcomp 没有让 JVM 启用 JIT 编译器的全部功能。因此在上图中，我们并没有看到-Xcomp 比-Xmixed 快多少。

**-Xmixed 代表混合模式(mixed mode)**，前面也提到了，混合模式是 JVM 的默认工作模式。它会同时使用编译模式和解释模式。**对于字节码中多次被调用的部分，JVM 会将其编译成本地代码以提高执行效率；而被调用很少(甚至只有一次)的方法在解释模式下会继续执行，从而减少编译和优化成本。**JIT 编译器在运行时创建方法使用文件，然后一步一步的优化每一个方法，有时候会主动的优化应用的行为。这些优化技术，比如积极的分支预测(optimistic branch prediction)，如果不先分析应用就不能有效的使用。这样将频繁调用的部分提取出来，编译成本地代码，也就是在应用中构建某种热点(**即 HotSpot，\*\***这也是 HotSpot JVM 名字的由来**)。**使用混合模式可以获得最好的执行效率\*\*。

### 切换 JVM 的工作模式

和切换 JVM 的类型一样，我们可以在命令行里显示指定使用 JVM 的何种模式，比如：

![img](http://static.oschina.net/uploads/space/2015/0918/131237_B8HC_1434710.png)

### 获取 JVM 的工作模式

在 JVM 运行时，我们可以通过下列代码检查 JVM 的类型和工作模式：
`System.out.println(System.getProperty("java.vm.name")); //获取JVM名字和类型 System.out.println(System.getProperty("java.vm.info")); //获取JVM的工作模式`

你可能得到以下结果：

![img](http://static.oschina.net/uploads/space/2015/0918/104909_fAfX_1434710.png)

# JVM Thread:JVM 中的线程

这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。run() 返回时，被处理未捕获异常，原生线程将确认由于它的结束是否要终止 JVM 进程(比如这个线程是最后一个非守护线程)。当线程结束时，会释放原生线程和 Java 线程的所有资源。对于整个 JVM 的学习中，我们会关注到线程独有的譬如内存区域中的程序计数器、虚拟机栈、本地栈和栈帧、局部变量数组、操作数栈、动态链接，以及线程共享的堆、非堆内存、内存管理、即时编译 JIT、方法区、类文件结构、类加载器、运行时常量池、异常表、符号表以及 Interned 字符串等等。
如果使用 jconsole 或者其它调试器，你会看到很多线程在后台运行。这些后台线程与触发 public static void main(String[]) 函数的主线程以及主线程创建的其他线程一起运行。Hotspot JVM 后台运行的系统线程主要有下面几个：

| 线程类型              | 说明                                                                                                                                                                                                                         |
| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 虚拟机线程(VM thread) | 这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-the-world 垃圾回收、线程栈 dump、线程暂停、线程偏向锁(biased locking)解除。 |
| 周期性任务线程        | 这线程负责定时器事件(也就是中断)，用来调度周期性操作的执行。                                                                                                                                                                 |
| GC 线程               | 这些线程支持 JVM 中不同的垃圾回收活动。                                                                                                                                                                                      |
| 编译器线程            | 这些线程在运行时将字节码动态编译成本地平台相关的机器码。                                                                                                                                                                     |
| 信号分发线程          | 这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。                                                                                                                                                                     |
