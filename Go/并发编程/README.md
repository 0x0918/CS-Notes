# Go 并发编程

Go 语言正是在多核和网络化的时代背景下诞生的原生支持并发的编程语言。Goroutine 是 Go 语言特有的并发体，是一种轻量级的线程，由 go 关键字启动。在真实的 Go 语言的实现中，goroutine 和系统线程也不是等价的。尽管两者的区别实际上只是一个量的区别，但正是这个量变引发了 Go 语言并发编程质的飞跃。协程的设计隐藏了线程创建和管理的诸多复杂性，在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待 IO，那么其它的线程就会运行。不过即便 协程相对轻量，但是也并不意味着可以无限制地开 协程。一个很典型的例子，比如在 CPU 密集型的计算中，开出超过 CPU 核心（线程）数的协程并不能加快计算速度，可能反而会适得其反。

目前 Go 运行时的实现默认并不会并行执行代码，它只为用户层代码提供单一的处理核心。任意数量的协程都可能在系统调用中被阻塞，而在任意时刻默认只有一个会执行用户层代码。它应当变得更智能，而且它将来肯定会变得更智能。但现在，若你希望 CPU 并行执行， 就必须告诉运行时你希望同时有多少协程能执行代码。有两种途径可意识形态，要么在运行你的工作时将 GOMAXPROCS 环境变量设为你要使用的核心数，要么导入 runtime 包并调用 runtime.GOMAXPROCS(NCPU)。runtime.NumCPU() 的值可能很有用，它会返回当前机器的逻辑 CPU 核心数。当然，随着调度算法和运行时的改进，将来会不再需要这种方法。

Go 不推荐使用共享内存的方式传递数据，而推荐使用 Channel（或称“通道”）在多个 goroutine 之间传递数据，同时保证整个过程的并发安全性。不过，作为可选方法，Go 依然提供了一些传统的同步方法（比如互斥量、条件变量等）。

# 链接

- https://www.kancloud.cn/mutouzhang/go/598654
