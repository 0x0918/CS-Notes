# 对象构建

new(T)会为类型为 T 分配已置零的内存空间，并返回它的地址，也就是一个类型为 `*T` 的值。用 Go 的术语来说，它返回一个指针，该指针指向新分配的，类型为 T 的零值。不像其他语言的关键字 new，除了赋零值外，Go 不会对其做任何初始化工作。

# 初始化方式

- 通过 var 声明结构体

在 Go 语言中当一个变量被声明的时候，系统会自动初始化它的默认值，比如 int 被初始化为 0，指针为 nil。var 声明同样也会为结构体类型的数据分配内存，所以我们才能像上一段代码中那样，在声明了 `var s T` 之后就能直接给他的字段进行赋值。

# 构造函数与复合字面（composite literal）

Go 其实不存在构造函数这种说法。有时（通常）零值还不够好，这时就需要一个初始化构造函数，他们通常是以 New 开头的导出方法，例如来自 os 包中的这段代码：

```go
func NewFile(fd int, name string) *File {
	if fd < 0 {
		return nil
	}
	f := new(File)
	f.fd = fd
	f.name = name
	f.dirinfo = nil
	f.nepipe = 0
	return f
}
```

为了使代码看上去更简洁，我们可以使用复合字面

```go
func NewFile(fd int, name string) *File {
    if fd < 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &f
}
```

最后两行可以简写成：

```go
    return &File{fd: fd, name: name}
```

# make 分配

`make(T, args...)` 仅用于创建 slice，map 和 channel, 并且返回类型为 T（不是 `*T`）。

```go
make([]int, 10, 100) // 创建一个长度为10，容量为100的slice
make([]int, 10) // 创建一个长度为10，容量为10的slice

make(map[string]string) // 创建一个 map

make(chan int) // 创建一个 chan
make(chan int, 10) // 创建一个 buffer size 为 10 的chan
```

# 单例模式

```go
var (
	instance *Singleton
	once     sync.Once
)

func Instance() *Singleton {
	once.Do(func() {
		instance = &Singleton{}
	})
	return instance
}
```
